<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venesa</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
            color: white;
        }

        #voice-screen {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(12px);
            position: relative;
        }

        /* Bottom-right blob container */
        #blob-container {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 10;
        }

        .ai {
            --s: 180px;
            --p: calc(var(--s) / 4);
            width: var(--s);
            aspect-ratio: 1;
            padding: var(--p);
            display: grid;
            place-items: center;
            position: relative;
            animation: circle1 5s ease-in-out infinite;
            filter: drop-shadow(0 8px 25px rgba(234, 170, 255, 0.4));

            &::before,
            &::after {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                width: 50%;
                height: 50%;
                border-radius: 50%;
                border: 2px solid white;
                box-shadow: 0 0 20px rgba(234, 170, 255, 1);
                filter: blur(4px);
                transform: translate(-50%, -50%);
                animation: wave 1.5s linear infinite;
            }

            &::after {
                animation-delay: 0.4s;
            }
        }

        .ai.listening::before,
        .ai.listening::after {
            border-color: #4CAF50;
            box-shadow: 0 0 25px rgba(76, 175, 80, 1);
        }

        .ai.speaking::before,
        .ai.speaking::after {
            border-color: #eaaaff;
            box-shadow: 0 0 30px rgba(234, 170, 255, 1);
            animation: waveSpeaking 0.8s linear infinite;
        }

        @keyframes wave {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }

            35% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }

            70%,
            100% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0;
            }
        }

        @keyframes waveSpeaking {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.4);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }
        }

        @keyframes ai1 {
            0% {
                transform: rotate(0deg) translate(50%) scale(0.9);
                opacity: 0;
            }

            25% {
                transform: rotate(90deg) translate(50%) scale(1.6);
                opacity: 1;
            }

            50% {
                transform: rotate(180deg) translate(50%) scale(0.7);
                opacity: 0.4;
            }

            75% {
                transform: rotate(270deg) translate(50%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: rotate(360deg) translate(50%) scale(0.9);
                opacity: 0;
            }
        }

        @keyframes ai2 {
            0% {
                transform: rotate(90deg) translate(50%) scale(0.5);
            }

            25% {
                transform: rotate(180deg) translate(50%) scale(1.5);
                opacity: 0;
            }

            50% {
                transform: rotate(270deg) translate(50%) scale(1);
                opacity: 0;
            }

            75% {
                transform: rotate(360deg) translate(50%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: rotate(450deg) translate(50%) scale(0.5);
                opacity: 1;
            }
        }

        @keyframes ai3 {
            0% {
                transform: rotate(180deg) translate(50%) scale(0.8);
                opacity: 0.8;
            }

            25% {
                transform: rotate(270deg) translate(50%) scale(1.4);
            }

            50% {
                transform: rotate(360deg) translate(50%) scale(0.6);
                opacity: 0.4;
            }

            75% {
                transform: rotate(450deg) translate(50%) scale(1.2);
                opacity: 0.7;
            }

            100% {
                transform: rotate(540deg) translate(50%) scale(0.8);
                opacity: 0.8;
            }
        }

        @keyframes ai4 {
            0% {
                transform: rotate(270deg) translate(50%) scale(1);
                opacity: 1;
            }

            25% {
                transform: rotate(360deg) translate(50%) scale(0.7);
            }

            50% {
                transform: rotate(450deg) translate(50%) scale(1.5);
                opacity: 0.5;
            }

            75% {
                transform: rotate(540deg) translate(50%) scale(0.9);
                opacity: 0.8;
            }

            100% {
                transform: rotate(630deg) translate(50%) scale(1);
                opacity: 1;
            }
        }

        .c {
            position: absolute;
            width: 180px;
            aspect-ratio: 1;
            border-radius: 50%;
        }

        .c1 {
            background: radial-gradient(50% 50% at center, #0066ff, #74bcd6);
            width: 120px;
            animation: ai1 5.5s linear infinite;
        }

        .c2 {
            background: radial-gradient(50% 50% at center, #ef788c, #e7e7fb);
            width: 70px;
            animation: ai2 6s linear infinite;
        }

        .c3 {
            background: radial-gradient(50% 50% at center, #eb7fc6, transparent);
            width: 100px;
            opacity: 0.6;
            animation: ai3 4.8s linear infinite;
        }

        .c4 {
            background: #6d67c8;
            animation: ai4 5.2s linear infinite;
        }

        .container {
            overflow: hidden;
            background: #b6a9f8;
            width: 100%;
            border-radius: 50%;
            aspect-ratio: 1;
            position: relative;
            display: grid;
            place-items: center;
        }

        .glass {
            overflow: hidden;
            position: absolute;
            inset: calc(var(--p) - 4px);
            border-radius: 50%;
            backdrop-filter: blur(8px);
            box-shadow:
                0 0 30px rgba(255, 255, 255, 0.3),
                0 30px 40px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(255, 255, 255, 1);
            background: radial-gradient(50px at 70% 30%, rgba(255, 255, 255, 0.7), transparent);
        }

        .rings {
            aspect-ratio: 1;
            border-radius: 50%;
            position: absolute;
            inset: 0;
            perspective: 11rem;
            opacity: 0.9;

            &:before,
            &:after {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 50%;
                border: 4px solid transparent;
                mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
                background: linear-gradient(white, blue, magenta, rgb(255, 7, 7), lightyellow) border-box;
                mask-composite: exclude;
            }
        }

        .rings::before {
            animation: ring180 10s ease-in-out infinite;
        }

        .rings::after {
            animation: ring90 10s ease-in-out infinite;
        }

        @keyframes ring180 {
            0% {
                transform: rotateY(180deg) rotateX(180deg) rotateZ(180deg);
            }

            25% {
                transform: rotateY(180deg) rotateX(180deg) rotateZ(180deg);
            }

            50% {
                transform: rotateY(360deg) rotateX(360deg) rotateZ(360deg);
            }

            80% {
                transform: rotateY(360deg) rotateX(360deg) rotateZ(360deg);
            }

            100% {
                transform: rotateY(540deg) rotateX(540deg) rotateZ(540deg);
            }
        }

        @keyframes ring90 {
            0% {
                transform: rotateY(90deg) rotateX(90deg) rotateZ(90deg);
            }

            25% {
                transform: rotateY(90deg) rotateX(90deg) rotateZ(90deg) scale(1.1);
            }

            50% {
                transform: rotateY(270deg) rotateX(270deg) rotateZ(270deg);
            }

            75% {
                transform: rotateY(270deg) rotateX(270deg) rotateZ(270deg);
            }

            100% {
                transform: rotateY(450deg) rotateX(450deg) rotateZ(450deg);
            }
        }

        @keyframes circle1 {

            0%,
            100% {
                transform: scale(0.97);
            }

            15%,
            85% {
                transform: scale(1);
            }

            30% {
                transform: scale(0.98);
            }

            45% {
                transform: scale(1);
            }

            60% {
                transform: scale(0.97);
            }
        }

        /* ===== SMOOTH MAC-INSPIRED SUBTITLES ===== */
        #subtitles-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            pointer-events: none;
        }

        #subtitle-bubble {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 16px 28px;
            border-radius: 28px;
            box-shadow:
                0 4px 30px rgba(0, 0, 0, 0.15),
                0 1px 3px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            display: none;
            max-width: 650px;
            will-change: transform, opacity;
        }

        #subtitle-bubble.visible {
            display: block;
            animation: bubbleIn 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        #subtitle-bubble.hiding {
            animation: bubbleOut 0.25s ease-out forwards;
        }

        @keyframes bubbleIn {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }

            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes bubbleOut {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }

            100% {
                opacity: 0;
                transform: scale(0.9) translateY(-10px);
            }
        }

        #subtitle-text {
            font-size: 26px;
            font-weight: 600;
            color: #1a1a1a;
            letter-spacing: -0.3px;
            line-height: 1.3;
            text-align: center;
            word-wrap: break-word;
        }

        /* Highlighted word styling */
        .word-span {
            display: inline;
            transition: color 0.15s ease, text-shadow 0.15s ease;
        }

        .word-span.past {
            color: #999;
        }

        .word-span.current {
            color: #8b5cf6;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
        }

        .word-span.future {
            color: #1a1a1a;
        }

        /* Status indicator */
        #status {
            position: fixed;
            top: 24px;
            left: 24px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(20px);
            padding: 10px 18px;
            border-radius: 24px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        /* Partial transcript */
        #partial {
            position: fixed;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            text-align: center;
            font-weight: 400;
            max-width: 80%;
        }

        /* Results panel */
        #voice-results {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            max-height: 60vh;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 12px;
            overflow-y: auto;
            display: none;
            z-index: 50;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        #voice-results.visible {
            display: block;
            animation: fadeSlideIn 0.3s ease-out forwards;
        }

        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #voice-results .result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            margin: 4px 0;
            border-radius: 10px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.15s ease;
        }

        #voice-results .result-item:hover,
        #voice-results .result-item.selected {
            background: rgba(234, 170, 255, 0.15);
            border-color: rgba(234, 170, 255, 0.3);
        }

        #voice-results .result-icon {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        #voice-results .result-icon svg {
            width: 18px;
            height: 18px;
            stroke: rgba(255, 255, 255, 0.7);
            stroke-width: 1.5;
            fill: none;
        }

        #voice-results .result-icon.app-icon svg {
            stroke: #88c0ff;
        }

        #voice-results .result-icon.folder-icon svg {
            stroke: #f5c542;
        }

        #voice-results .result-content {
            flex: 1;
            min-width: 0;
        }

        #voice-results .result-name {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #voice-results .result-path {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #voice-results .result-index {
            font-size: 12px;
            color: rgba(234, 170, 255, 0.8);
            font-weight: 600;
            min-width: 20px;
        }

        #voice-results-header {
            padding: 8px 14px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
        }
    </style>
</head>

<body>
    <div id="voice-screen">
        <div id="status">Initializing</div>
        <div id="partial"></div>

        <div id="voice-results">
            <div id="voice-results-header">Say a number to select, or say "cancel"</div>
            <div id="voice-results-list"></div>
        </div>

        <!-- Clean Mac-style subtitle bubble -->
        <div id="subtitles-container">
            <div id="subtitle-bubble">
                <div id="subtitle-text"></div>
            </div>
        </div>

        <div id="blob-container">
            <div class="ai">
                <div class="container">
                    <div class="c c4"></div>
                    <div class="c c1"></div>
                    <div class="c c2"></div>
                    <div class="c c3"></div>
                    <div class="rings"></div>
                </div>
                <div class="glass"></div>
            </div>
        </div>
    </div>

    <script>
        const VoiceState = {
            IDLE: 'idle',
            LISTENING: 'listening',
            PROCESSING: 'processing',
            SHOWING_RESULTS: 'showing_results',
            AWAITING_SELECTION: 'awaiting_selection',
            SPEAKING: 'speaking'
        };

        let currentState = VoiceState.IDLE;
        let isListening = false;
        let isSpeaking = false;
        let audioContext = null;
        let mediaStream = null;
        let workletNode = null;
        let scriptProcessor = null;
        let currentAudio = null;
        let screenCaptured = false;
        let capturedImage = null;
        let currentWordIndex = 0;
        let words = [];
        let karaokeInterval = null;
        let wordSpans = [];
        let awaitingAudio = false; // Flag to track if we're waiting for TTS audio

        const MAX_CONSECUTIVE_LISTENS = 3;
        let consecutiveListenCount = 0;
        let currentVoiceResults = [];


        const statusEl = document.getElementById('status');
        const partialEl = document.getElementById('partial');
        const subtitleBubble = document.getElementById('subtitle-bubble');
        const subtitleText = document.getElementById('subtitle-text');
        const blobEl = document.querySelector('.ai');
        const voiceResultsEl = document.getElementById('voice-results');
        const voiceResultsListEl = document.getElementById('voice-results-list');

        function setState(newState) {
            console.log(`[VoiceWindow] State: ${currentState} -> ${newState}`);
            currentState = newState;

            switch (newState) {
                case VoiceState.IDLE:
                    blobEl.className = 'ai';
                    statusEl.textContent = '';
                    break;
                case VoiceState.LISTENING:
                    blobEl.className = 'ai listening';
                    statusEl.textContent = 'Listening';
                    break;
                case VoiceState.PROCESSING:
                    blobEl.className = 'ai';
                    statusEl.textContent = 'Processing';
                    break;
                case VoiceState.SHOWING_RESULTS:
                    blobEl.className = 'ai';
                    statusEl.textContent = 'Select an item';
                    break;
                case VoiceState.AWAITING_SELECTION:
                    blobEl.className = 'ai listening';
                    statusEl.textContent = 'Listening for selection';
                    break;
                case VoiceState.SPEAKING:
                    blobEl.className = 'ai speaking';
                    statusEl.textContent = 'Speaking';
                    break;
            }
        }

        function resetListenCounter() { consecutiveListenCount = 0; }
        function canAutoListen() { return consecutiveListenCount < MAX_CONSECUTIVE_LISTENS; }

        function float32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16Array;
        }

        function downsample(buffer, fromRate, toRate) {
            if (fromRate === toRate) return buffer;
            const ratio = fromRate / toRate;
            const newLength = Math.round(buffer.length / ratio);
            const result = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
                result[i] = buffer[Math.round(i * ratio)];
            }
            return result;
        }

        function getAppIcon() {
            return '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="3" width="7" height="7" rx="1"></rect><rect x="3" y="14" width="7" height="7" rx="1"></rect><rect x="14" y="14" width="7" height="7" rx="1"></rect></svg>';
        }

        function getFolderIcon() {
            return '<svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
        }

        function getFileIcon() {
            return '<svg viewBox="0 0 24 24"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>';
        }

        function displayVoiceResults(results) {
            currentVoiceResults = [];
            voiceResultsListEl.innerHTML = '';

            const apps = results.apps || [];
            const files = results.files || [];
            const folders = results.folders || [];
            let index = 1;

            apps.slice(0, 3).forEach(app => {
                currentVoiceResults.push({ type: 'app', data: app });
                voiceResultsListEl.appendChild(createResultItem(index++, app.name, 'Application', 'app-icon', getAppIcon()));
            });

            folders.slice(0, 3).forEach(folderPath => {
                const folderName = folderPath.split(/[\\/]/).pop();
                currentVoiceResults.push({ type: 'folder', data: folderPath });
                voiceResultsListEl.appendChild(createResultItem(index++, folderName, 'Folder', 'folder-icon', getFolderIcon()));
            });

            files.slice(0, 4).forEach(filePath => {
                const fileName = filePath.split(/[\\/]/).pop();
                currentVoiceResults.push({ type: 'file', data: filePath });
                voiceResultsListEl.appendChild(createResultItem(index++, fileName, 'File', '', getFileIcon()));
            });

            if (currentVoiceResults.length > 0) {
                voiceResultsEl.classList.add('visible');
                setState(VoiceState.SHOWING_RESULTS);
            }
        }

        function createResultItem(index, name, type, iconClass, iconSvg) {
            const item = document.createElement('div');
            item.className = 'result-item';
            item.dataset.index = index;
            item.innerHTML = `
                <span class="result-index">${index}</span>
                <div class="result-icon ${iconClass}">${iconSvg}</div>
                <div class="result-content">
                    <div class="result-name">${escapeHtml(name)}</div>
                    <div class="result-path">${type}</div>
                </div>
            `;
            item.addEventListener('click', () => selectResult(index));
            return item;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function selectResult(index) {
            if (index < 1 || index > currentVoiceResults.length) return;
            const selected = currentVoiceResults[index - 1];
            hideVoiceResults();
            const data = selected.data;

            if (selected.type === 'app') {
                if (typeof data === 'object' && data.path) {
                    window.voiceApi.send('launch-app', data);
                } else if (typeof data === 'object' && data.name) {
                    window.voiceApi.send('launch-app', { name: data.name, path: data.path || '' });
                } else {
                    window.voiceApi.send('launch-app', { name: String(data), path: typeof data === 'string' ? data : '' });
                }
            } else if (selected.type === 'folder') {
                window.voiceApi.send('open-folder', typeof data === 'string' ? data : (data.path || data.name || ''));
            } else if (selected.type === 'file') {
                window.voiceApi.send('open-file', typeof data === 'string' ? data : (data.path || data.name || ''));
            }

            setTimeout(() => window.voiceApi.send('auto-close-voice'), 500);
        }

        function hideVoiceResults() {
            voiceResultsEl.classList.remove('visible');
            currentVoiceResults = [];
        }

        function parseSelectionFromVoice(text) {
            if (!text) return null;
            const lower = text.toLowerCase().trim();

            if (lower.includes('cancel') || lower.includes('close') || lower.includes('never mind')) {
                return 'cancel';
            }

            const numMatch = lower.match(/\b(one|two|three|four|five|six|seven|eight|nine|ten|\d)\b/);
            if (numMatch) {
                const wordToNum = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10 };
                const num = wordToNum[numMatch[1]] || parseInt(numMatch[1]);
                if (num >= 1 && num <= currentVoiceResults.length) return num;
            }
            return null;
        }

        // ===== SMOOTH KARAOKE SUBTITLES =====
        function startKaraoke(text, duration) {
            words = text.split(' ').filter(w => w.trim());
            currentWordIndex = 0;
            wordSpans = [];

            if (words.length === 0) return;

            // Build HTML with spans for each word
            subtitleText.innerHTML = words.map((word, i) =>
                `<span class="word-span future" data-index="${i}">${escapeHtml(word)}</span>`
            ).join(' ');

            wordSpans = Array.from(subtitleText.querySelectorAll('.word-span'));

            // Show bubble with animation
            subtitleBubble.classList.remove('hiding');
            subtitleBubble.classList.add('visible');

            // Mark first word as current
            if (wordSpans[0]) {
                wordSpans[0].classList.remove('future');
                wordSpans[0].classList.add('current');
            }

            if (words.length <= 1) {
                setTimeout(() => hideSubtitles(), duration + 500);
                return;
            }

            const wordDuration = duration / words.length;

            karaokeInterval = setInterval(() => {
                if (currentWordIndex < words.length - 1) {
                    // Move previous word to past
                    if (wordSpans[currentWordIndex]) {
                        wordSpans[currentWordIndex].classList.remove('current');
                        wordSpans[currentWordIndex].classList.add('past');
                    }

                    currentWordIndex++;

                    // Highlight current word
                    if (wordSpans[currentWordIndex]) {
                        wordSpans[currentWordIndex].classList.remove('future');
                        wordSpans[currentWordIndex].classList.add('current');
                    }
                } else {
                    clearInterval(karaokeInterval);
                    karaokeInterval = null;
                    setTimeout(() => hideSubtitles(), 600);
                }
            }, wordDuration);
        }

        function hideSubtitles() {
            subtitleBubble.classList.add('hiding');
            setTimeout(() => {
                subtitleBubble.classList.remove('visible', 'hiding');
                subtitleText.innerHTML = '';
                wordSpans = [];
            }, 250);
        }

        async function startListening() {
            console.log('[VoiceWindow] startListening() called');

            // Tell main process to restart STT service (it stops itself after getting a result)
            window.voiceApi.send('restart-stt');

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });

                audioContext = new AudioContext({ sampleRate: 48000 });
                const source = audioContext.createMediaStreamSource(mediaStream);

                try {
                    await audioContext.audioWorklet.addModule('workers/audio.processor.js');
                    workletNode = new AudioWorkletNode(audioContext, 'audio-capture-processor');
                    workletNode.port.onmessage = (event) => {
                        if (!isListening) return;
                        if (event.data.type === 'audio') {
                            const downsampled = downsample(event.data.buffer, audioContext.sampleRate, 16000);
                            const int16Data = float32ToInt16(downsampled);
                            window.voiceApi.send('audio-data', int16Data.buffer);
                        }
                    };
                    source.connect(workletNode);
                } catch (e) {
                    scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                    scriptProcessor.onaudioprocess = (e) => {
                        if (!isListening) return;
                        const inputData = e.inputBuffer.getChannelData(0);
                        const downsampled = downsample(inputData, audioContext.sampleRate, 16000);
                        const int16Data = float32ToInt16(downsampled);
                        window.voiceApi.send('audio-data', int16Data.buffer);
                    };
                    source.connect(scriptProcessor);
                    scriptProcessor.connect(audioContext.destination);
                }

                isListening = true;
                setState(currentVoiceResults.length > 0 ? VoiceState.AWAITING_SELECTION : VoiceState.LISTENING);
                screenCaptured = false;
                window.voiceApi.send('capture-screen');
            } catch (err) {
                console.error('[VoiceWindow] Mic error:', err);
                statusEl.textContent = 'Mic Error';
                try { window.voiceApi.send('close-voice-window'); } catch (e) { }
            }
        }

        function stopListening() {
            isListening = false;
            if (workletNode) { try { workletNode.disconnect(); } catch (e) { } workletNode = null; }
            if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
            if (audioContext && audioContext.state !== 'closed') { audioContext.close(); audioContext = null; }
            if (currentState === VoiceState.LISTENING || currentState === VoiceState.AWAITING_SELECTION) {
                setState(VoiceState.PROCESSING);
            }
        }

        let shouldListenAgain = false;

        window.voiceApi.receive('continue-listening', () => {
            console.log('[VoiceWindow] continue-listening received');
            if (canAutoListen()) {
                shouldListenAgain = true;
                consecutiveListenCount++;
                console.log(`[VoiceWindow] shouldListenAgain=true, awaitingAudio=${awaitingAudio}, isSpeaking=${isSpeaking}`);

                // Only start listening immediately if NOT waiting for audio and NOT speaking
                if (!isSpeaking && !currentAudio && !awaitingAudio) {
                    console.log('[VoiceWindow] Not speaking/awaiting - starting listening immediately');
                    shouldListenAgain = false;
                    setState(VoiceState.LISTENING);
                    setTimeout(() => startListening(), 200);
                }
                // Otherwise, shouldListenAgain flag will be checked when audio ends
            } else {
                console.log('[VoiceWindow] Max listens reached');
                shouldListenAgain = false;
            }
        });

        function playAudioResponse(audioDataUrl, responseText) {
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            if (karaokeInterval) { clearInterval(karaokeInterval); karaokeInterval = null; }

            currentAudio = new Audio(audioDataUrl);
            isSpeaking = true;
            setState(VoiceState.SPEAKING);

            currentAudio.onloadedmetadata = () => {
                startKaraoke(responseText, currentAudio.duration * 1000);
            };

            currentAudio.onended = () => {
                isSpeaking = false;
                currentAudio = null;

                if (currentVoiceResults.length > 0) {
                    setState(VoiceState.SHOWING_RESULTS);
                    setTimeout(() => startListening(), 300);
                } else if (shouldListenAgain) {
                    console.log('[VoiceWindow] Audio ended, shouldListenAgain=true');
                    shouldListenAgain = false;
                    setState(VoiceState.LISTENING);
                    setTimeout(() => startListening(), 200);
                } else {
                    setState(VoiceState.IDLE);
                    setTimeout(() => {
                        if (currentVoiceResults.length === 0) window.voiceApi.send('auto-close-voice');
                    }, 1500);
                }
            };

            currentAudio.onerror = () => {
                isSpeaking = false;
                currentAudio = null;
                // Clean up subtitles on error
                if (karaokeInterval) { clearInterval(karaokeInterval); karaokeInterval = null; }
                hideSubtitles();
                if (shouldListenAgain) {
                    shouldListenAgain = false;
                    setState(VoiceState.LISTENING);
                    setTimeout(() => startListening(), 200);
                } else {
                    setState(VoiceState.IDLE);
                }
            };

            currentAudio.play().catch(err => {
                console.error('[VoiceWindow] Playback failed:', err);
                isSpeaking = false;
                currentAudio = null;
                // Clean up subtitles on playback failure
                if (karaokeInterval) { clearInterval(karaokeInterval); karaokeInterval = null; }
                hideSubtitles();
                if (shouldListenAgain) {
                    shouldListenAgain = false;
                    setState(VoiceState.LISTENING);
                    setTimeout(() => startListening(), 200);
                }
            });
        }

        // IPC Listeners
        window.voiceApi.receive('screen-captured', (imageData) => {
            screenCaptured = true;
            capturedImage = imageData;
        });

        window.voiceApi.receive('stt-partial-result', (text) => {
            if (text) partialEl.textContent = text;
        });

        window.voiceApi.receive('stt-result', (text) => {
            partialEl.textContent = '';

            if (currentState === VoiceState.AWAITING_SELECTION && currentVoiceResults.length > 0) {
                stopListening();
                const selection = parseSelectionFromVoice(text);
                if (selection === 'cancel') {
                    hideVoiceResults();
                    window.voiceApi.send('auto-close-voice');
                    return;
                } else if (typeof selection === 'number') {
                    selectResult(selection);
                    return;
                }
            }

            stopListening();
            setState(VoiceState.PROCESSING);
            window.voiceApi.send('voice-query', { query: text, image: capturedImage });
        });

        window.voiceApi.receive('voice-response', (data) => {
            if (data.text) {
                words = data.text.split(' ').filter(w => w.trim());
                statusEl.textContent = 'Synthesizing';
                awaitingAudio = true; // Mark that we're waiting for TTS audio
                if (data.audio) {
                    awaitingAudio = false;
                    playAudioResponse(data.audio, data.text);
                }
            }
        });

        window.voiceApi.receive('voice-audio-ready', (audioDataUrl) => {
            awaitingAudio = false; // Audio arrived (or failed)
            if (audioDataUrl && words.length > 0) {
                playAudioResponse(audioDataUrl, words.join(' '));
            } else if (shouldListenAgain) {
                console.log('[VoiceWindow] No audio but shouldListenAgain=true - starting listening');
                shouldListenAgain = false;
                setState(VoiceState.LISTENING);
                setTimeout(() => startListening(), 200);
            } else {
                // No audio and not listening again - close after delay
                setState(VoiceState.IDLE);
                setTimeout(() => {
                    if (currentVoiceResults.length === 0) window.voiceApi.send('auto-close-voice');
                }, 1500);
            }
        });

        window.voiceApi.receive('voice-search-results', (results) => {
            try {
                const data = typeof results === 'string' ? JSON.parse(results) : results;

                if (data.results && Array.isArray(data.results)) {
                    currentVoiceResults = data.results.map(item => ({
                        type: item.type,
                        data: item.data !== undefined ? item.data : item
                    }));
                    voiceResultsListEl.innerHTML = '';

                    data.results.forEach((item, i) => {
                        let iconSvg, iconClass;
                        if (item.type === 'app') { iconSvg = getAppIcon(); iconClass = 'app-icon'; }
                        else if (item.type === 'folder') { iconSvg = getFolderIcon(); iconClass = 'folder-icon'; }
                        else { iconSvg = getFileIcon(); iconClass = ''; }
                        voiceResultsListEl.appendChild(createResultItem(i + 1, item.name, item.type, iconClass, iconSvg));
                    });

                    if (currentVoiceResults.length > 0) {
                        voiceResultsEl.classList.add('visible');
                        setState(VoiceState.SHOWING_RESULTS);
                    }
                } else {
                    displayVoiceResults(data);
                }

                // NOTE: Don't start listening here! Audio is still playing the results list.
                // Listening will start automatically when audio ends (shouldListenAgain flag).
            } catch (e) {
                console.error('[VoiceWindow] Failed to parse search results:', e);
            }
        });

        window.voiceApi.receive('start-listening', () => {
            resetListenCounter();
            startListening();
        });

        window.voiceApi.receive('stop-listening', () => stopListening());

        document.getElementById('voice-results').addEventListener('click', e => e.stopPropagation());

        document.body.addEventListener('click', (e) => {
            if (e.target.closest('#voice-results')) return;
            stopListening();
            hideVoiceResults();
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            if (karaokeInterval) { clearInterval(karaokeInterval); karaokeInterval = null; }
            hideSubtitles();
            setState(VoiceState.IDLE);
            window.voiceApi.send('close-voice-window');
        });

        window.addEventListener('load', () => window.voiceApi.send('voice-window-ready'));
        window.addEventListener('beforeunload', () => {
            stopListening();
            hideVoiceResults();
            window.voiceApi.send('voice-window-closed');
        });
    </script>
</body>

</html>