<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venesa</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
            color: white;
        }

        /* Transparent overlay */
        #voice-screen {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            position: relative;
        }

        /* Bottom-right blob container */
        #blob-container {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 10;
        }

        /* Smaller blob */
        .ai {
            --s: 180px;
            --p: calc(var(--s) / 4);
            width: var(--s);
            aspect-ratio: 1;
            padding: var(--p);
            display: grid;
            place-items: center;
            position: relative;
            animation: circle1 5s ease-in-out infinite;
            filter: drop-shadow(0 8px 25px rgba(234, 170, 255, 0.4));

            &::before,
            &::after {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                width: 50%;
                height: 50%;
                border-radius: 50%;
                border: 2px solid white;
                box-shadow: 0 0 20px rgba(234, 170, 255, 1);
                filter: blur(4px);
                transform: translate(-50%, -50%);
                animation: wave 1.5s linear infinite;
            }

            &::after {
                animation-delay: 0.4s;
            }
        }

        .ai.listening::before,
        .ai.listening::after {
            border-color: #4CAF50;
            box-shadow: 0 0 25px rgba(76, 175, 80, 1);
        }

        .ai.speaking::before,
        .ai.speaking::after {
            border-color: #eaaaff;
            box-shadow: 0 0 30px rgba(234, 170, 255, 1);
            animation: waveSpeaking 0.8s linear infinite;
        }

        @keyframes wave {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }

            35% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }

            70%,
            100% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0;
            }
        }

        @keyframes waveSpeaking {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.4);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }
        }

        @keyframes ai1 {
            0% {
                transform: rotate(0deg) translate(50%) scale(0.9);
                opacity: 0;
            }

            25% {
                transform: rotate(90deg) translate(50%) scale(1.6);
                opacity: 1;
            }

            50% {
                transform: rotate(180deg) translate(50%) scale(0.7);
                opacity: 0.4;
            }

            75% {
                transform: rotate(270deg) translate(50%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: rotate(360deg) translate(50%) scale(0.9);
                opacity: 0;
            }
        }

        @keyframes ai2 {
            0% {
                transform: rotate(90deg) translate(50%) scale(0.5);
            }

            25% {
                transform: rotate(180deg) translate(50%) scale(1.5);
                opacity: 0;
            }

            50% {
                transform: rotate(270deg) translate(50%) scale(1);
                opacity: 0;
            }

            75% {
                transform: rotate(360deg) translate(50%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: rotate(450deg) translate(50%) scale(0.5);
                opacity: 1;
            }
        }

        @keyframes ai3 {
            0% {
                transform: rotate(180deg) translate(50%) scale(0.8);
                opacity: 0.8;
            }

            25% {
                transform: rotate(270deg) translate(50%) scale(1.4);
            }

            50% {
                transform: rotate(360deg) translate(50%) scale(0.6);
                opacity: 0.4;
            }

            75% {
                transform: rotate(450deg) translate(50%) scale(1.2);
                opacity: 0.7;
            }

            100% {
                transform: rotate(540deg) translate(50%) scale(0.8);
                opacity: 0.8;
            }
        }

        @keyframes ai4 {
            0% {
                transform: rotate(270deg) translate(50%) scale(1);
                opacity: 1;
            }

            25% {
                transform: rotate(360deg) translate(50%) scale(0.7);
            }

            50% {
                transform: rotate(450deg) translate(50%) scale(1.5);
                opacity: 0.5;
            }

            75% {
                transform: rotate(540deg) translate(50%) scale(0.9);
                opacity: 0.8;
            }

            100% {
                transform: rotate(630deg) translate(50%) scale(1);
                opacity: 1;
            }
        }

        .c {
            position: absolute;
            width: 180px;
            aspect-ratio: 1;
            border-radius: 50%;
        }

        .c1 {
            background: radial-gradient(50% 50% at center, #0066ff, #74bcd6);
            width: 120px;
            animation: ai1 5.5s linear infinite;
        }

        .c2 {
            background: radial-gradient(50% 50% at center, #ef788c, #e7e7fb);
            width: 70px;
            animation: ai2 6s linear infinite;
        }

        .c3 {
            background: radial-gradient(50% 50% at center, #eb7fc6, transparent);
            width: 100px;
            opacity: 0.6;
            animation: ai3 4.8s linear infinite;
        }

        .c4 {
            background: #6d67c8;
            animation: ai4 5.2s linear infinite;
        }

        .container {
            overflow: hidden;
            background: #b6a9f8;
            width: 100%;
            border-radius: 50%;
            aspect-ratio: 1;
            position: relative;
            display: grid;
            place-items: center;
        }

        .glass {
            overflow: hidden;
            position: absolute;
            inset: calc(var(--p) - 4px);
            border-radius: 50%;
            backdrop-filter: blur(8px);
            box-shadow:
                0 0 30px rgba(255, 255, 255, 0.3),
                0 30px 40px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(255, 255, 255, 1);
            background: radial-gradient(50px at 70% 30%,
                    rgba(255, 255, 255, 0.7),
                    transparent);
        }

        .rings {
            aspect-ratio: 1;
            border-radius: 50%;
            position: absolute;
            inset: 0;
            perspective: 11rem;
            opacity: 0.9;

            &:before,
            &:after {
                content: "";
                position: absolute;
                inset: 0;
                background: rgba(255, 0, 0, 1);
                border-radius: 50%;
                border: 4px solid transparent;
                mask:
                    linear-gradient(#fff 0 0) padding-box,
                    linear-gradient(#fff 0 0);
                background: linear-gradient(white, blue, magenta, rgb(255, 7, 7), lightyellow) border-box;
                mask-composite: exclude;
            }
        }

        .rings::before {
            animation: ring180 10s ease-in-out infinite;
        }

        .rings::after {
            animation: ring90 10s ease-in-out infinite;
        }

        @keyframes ring180 {
            0% {
                transform: rotateY(180deg) rotateX(180deg) rotateZ(180deg);
            }

            25% {
                transform: rotateY(180deg) rotateX(180deg) rotateZ(180deg);
            }

            50% {
                transform: rotateY(360deg) rotateX(360deg) rotateZ(360deg);
            }

            80% {
                transform: rotateY(360deg) rotateX(360deg) rotateZ(360deg);
            }

            100% {
                transform: rotateY(540deg) rotateX(540deg) rotateZ(540deg);
            }
        }

        @keyframes ring90 {
            0% {
                transform: rotateY(90deg) rotateX(90deg) rotateZ(90deg);
            }

            25% {
                transform: rotateY(90deg) rotateX(90deg) rotateZ(90deg) scale(1.1);
            }

            50% {
                transform: rotateY(270deg) rotateX(270deg) rotateZ(270deg);
            }

            75% {
                transform: rotateY(270deg) rotateX(270deg) rotateZ(270deg);
            }

            100% {
                transform: rotateY(450deg) rotateX(450deg) rotateZ(450deg);
            }
        }

        @keyframes circle1 {

            0%,
            100% {
                transform: scale(0.97);
            }

            15%,
            85% {
                transform: scale(1);
            }

            30% {
                transform: scale(0.98);
            }

            45% {
                transform: scale(1);
            }

            60% {
                transform: scale(0.97);
            }
        }

        /* Smooth horizontal scrolling subtitles */
        #subtitles {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            padding: 18px 32px;
            border-radius: 30px;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.4);
            z-index: 100;
            overflow: hidden;
            max-width: 600px;
        }

        #subtitle-track {
            display: flex;
            gap: 16px;
            align-items: center;
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform;
        }

        .word {
            font-size: 28px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .word.current {
            color: #eaaaff;
            text-shadow: 0 0 20px rgba(234, 170, 255, 0.7);
        }

        /* Status indicator (small, top-left) */
        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Partial transcript (small, above subtitles) */
        #partial {
            position: fixed;
            bottom: 170px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
            text-align: center;
        }

        /* Results panel for voice mode - reuses main window styling */
        #voice-results {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            max-height: 60vh;
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 12px;
            overflow-y: auto;
            display: none;
            z-index: 50;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        #voice-results.visible {
            display: block;
            animation: fadeSlideIn 0.3s ease-out forwards;
        }

        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #voice-results .result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            margin: 4px 0;
            border-radius: 10px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.15s ease;
        }

        #voice-results .result-item:hover,
        #voice-results .result-item.selected {
            background: rgba(234, 170, 255, 0.15);
            border-color: rgba(234, 170, 255, 0.3);
        }

        #voice-results .result-icon {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        #voice-results .result-icon svg {
            width: 18px;
            height: 18px;
            stroke: rgba(255, 255, 255, 0.7);
            stroke-width: 1.5;
            fill: none;
        }

        #voice-results .result-icon.app-icon svg {
            stroke: #88c0ff;
        }

        #voice-results .result-icon.folder-icon svg {
            stroke: #f5c542;
        }

        #voice-results .result-content {
            flex: 1;
            min-width: 0;
        }

        #voice-results .result-name {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #voice-results .result-path {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #voice-results .result-index {
            font-size: 12px;
            color: rgba(234, 170, 255, 0.8);
            font-weight: 600;
            min-width: 20px;
        }

        #voice-results-header {
            padding: 8px 14px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
        }
    </style>
</head>

<body>
    <div id="voice-screen">
        <div id="status">Initializing</div>
        <div id="partial"></div>

        <!-- Results panel for search results in voice mode -->
        <div id="voice-results">
            <div id="voice-results-header">Say a number to select, or say "cancel"</div>
            <div id="voice-results-list"></div>
        </div>

        <div id="subtitles" style="display: none;">
            <div id="subtitle-track"></div>
        </div>

        <div id="blob-container">
            <div class="ai">
                <div class="container">
                    <div class="c c4"></div>
                    <div class="c c1"></div>
                    <div class="c c2"></div>
                    <div class="c c3"></div>
                    <div class="rings"></div>
                </div>
                <div class="glass"></div>
            </div>
        </div>
    </div>

    <script>
        // === STATE MANAGEMENT ===
        const VoiceState = {
            IDLE: 'idle',
            LISTENING: 'listening',
            PROCESSING: 'processing',
            SHOWING_RESULTS: 'showing_results',
            AWAITING_SELECTION: 'awaiting_selection',
            SPEAKING: 'speaking'
        };

        let currentState = VoiceState.IDLE;
        let isListening = false;
        let isSpeaking = false;
        let audioContext = null;
        let mediaStream = null;
        let workletNode = null;
        let scriptProcessor = null;
        let currentAudio = null;
        let screenCaptured = false;
        let capturedImage = null;
        let currentWordIndex = 0;
        let words = [];
        let karaokeInterval = null;

        // Consecutive listen counter - limit to 3 without explicit user trigger
        const MAX_CONSECUTIVE_LISTENS = 3;
        let consecutiveListenCount = 0;

        // Current search results for voice selection
        let currentVoiceResults = [];

        const statusEl = document.getElementById('status');
        const partialEl = document.getElementById('partial');
        const subtitlesEl = document.getElementById('subtitles');
        const subtitleTrack = document.getElementById('subtitle-track');
        const blobEl = document.querySelector('.ai');
        const voiceResultsEl = document.getElementById('voice-results');
        const voiceResultsListEl = document.getElementById('voice-results-list');

        // State transition function
        function setState(newState) {
            console.log(`[VoiceWindow] State: ${currentState} -> ${newState}`);
            currentState = newState;

            switch (newState) {
                case VoiceState.IDLE:
                    blobEl.className = 'ai';
                    statusEl.textContent = '';
                    break;
                case VoiceState.LISTENING:
                    blobEl.className = 'ai listening';
                    statusEl.textContent = 'Listening';
                    break;
                case VoiceState.PROCESSING:
                    blobEl.className = 'ai';
                    statusEl.textContent = 'Processing';
                    break;
                case VoiceState.SHOWING_RESULTS:
                    blobEl.className = 'ai';
                    statusEl.textContent = 'Select an item';
                    break;
                case VoiceState.AWAITING_SELECTION:
                    blobEl.className = 'ai listening';
                    statusEl.textContent = 'Listening for selection';
                    break;
                case VoiceState.SPEAKING:
                    blobEl.className = 'ai speaking';
                    statusEl.textContent = 'Speaking';
                    break;
            }
        }

        // Reset consecutive listen counter on explicit user activation
        function resetListenCounter() {
            consecutiveListenCount = 0;
        }

        // Check if we can auto-listen again
        function canAutoListen() {
            return consecutiveListenCount < MAX_CONSECUTIVE_LISTENS;
        }

        // Utility functions
        function float32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16Array;
        }

        function downsample(buffer, fromRate, toRate) {
            if (fromRate === toRate) return buffer;
            const ratio = fromRate / toRate;
            const newLength = Math.round(buffer.length / ratio);
            const result = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
                result[i] = buffer[Math.round(i * ratio)];
            }
            return result;
        }

        // Icon helpers for result display
        function getAppIcon() {
            return '<svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"></rect><rect x="14" y="3" width="7" height="7" rx="1"></rect><rect x="3" y="14" width="7" height="7" rx="1"></rect><rect x="14" y="14" width="7" height="7" rx="1"></rect></svg>';
        }

        function getFolderIcon() {
            return '<svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
        }

        function getFileIcon() {
            return '<svg viewBox="0 0 24 24"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>';
        }

        // Display search results in voice mode
        function displayVoiceResults(results) {
            currentVoiceResults = [];
            voiceResultsListEl.innerHTML = '';

            const apps = results.apps || [];
            const files = results.files || [];
            const folders = results.folders || [];

            let index = 1;

            // Add apps
            apps.slice(0, 3).forEach(app => {
                currentVoiceResults.push({ type: 'app', data: app });
                const item = createResultItem(index++, app.name, 'Application', 'app-icon', getAppIcon());
                voiceResultsListEl.appendChild(item);
            });

            // Add folders
            folders.slice(0, 3).forEach(folderPath => {
                const folderName = folderPath.split(/[\\/]/).pop();
                currentVoiceResults.push({ type: 'folder', data: folderPath });
                const item = createResultItem(index++, folderName, 'Folder', 'folder-icon', getFolderIcon());
                voiceResultsListEl.appendChild(item);
            });

            // Add files
            files.slice(0, 4).forEach(filePath => {
                const fileName = filePath.split(/[\\/]/).pop();
                currentVoiceResults.push({ type: 'file', data: filePath });
                const item = createResultItem(index++, fileName, 'File', '', getFileIcon());
                voiceResultsListEl.appendChild(item);
            });

            if (currentVoiceResults.length > 0) {
                voiceResultsEl.classList.add('visible');
                setState(VoiceState.SHOWING_RESULTS);
            }
        }

        function createResultItem(index, name, type, iconClass, iconSvg) {
            const item = document.createElement('div');
            item.className = 'result-item';
            item.dataset.index = index;
            item.innerHTML = `
                <span class="result-index">${index}</span>
                <div class="result-icon ${iconClass}">${iconSvg}</div>
                <div class="result-content">
                    <div class="result-name">${escapeHtml(name)}</div>
                    <div class="result-path">${type}</div>
                </div>
            `;
            item.addEventListener('click', () => selectResult(index));
            return item;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Handle result selection
        function selectResult(index) {
            if (index < 1 || index > currentVoiceResults.length) return;

            const selected = currentVoiceResults[index - 1];
            hideVoiceResults();

            // Handle different data formats
            const data = selected.data;

            if (selected.type === 'app') {
                // App data can be an object with path, or just a path string
                if (typeof data === 'object' && data.path) {
                    window.voiceApi.send('launch-app', data);
                } else if (typeof data === 'object' && data.name) {
                    window.voiceApi.send('launch-app', { name: data.name, path: data.path || '' });
                } else {
                    window.voiceApi.send('launch-app', { name: String(data), path: typeof data === 'string' ? data : '' });
                }
            } else if (selected.type === 'folder') {
                const folderPath = typeof data === 'string' ? data : (data.path || data.name || '');
                window.voiceApi.send('open-folder', folderPath);
            } else if (selected.type === 'file') {
                const filePath = typeof data === 'string' ? data : (data.path || data.name || '');
                window.voiceApi.send('open-file', filePath);
            }

            // Close after selection
            setTimeout(() => {
                window.voiceApi.send('auto-close-voice');
            }, 500);
        }

        function hideVoiceResults() {
            voiceResultsEl.classList.remove('visible');
            currentVoiceResults = [];
        }

        // Parse voice input for result selection
        function parseSelectionFromVoice(text) {
            if (!text) return null;
            const lower = text.toLowerCase().trim();

            // Check for cancel
            if (lower.includes('cancel') || lower.includes('close') || lower.includes('never mind')) {
                return 'cancel';
            }

            // Check for number (1-9)
            const numMatch = lower.match(/\b(one|two|three|four|five|six|seven|eight|nine|ten|\d)\b/);
            if (numMatch) {
                const wordToNum = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10 };
                const num = wordToNum[numMatch[1]] || parseInt(numMatch[1]);
                if (num >= 1 && num <= currentVoiceResults.length) {
                    return num;
                }
            }

            return null;
        }

        // Smooth horizontal scrolling karaoke
        function startKaraoke(text, duration) {
            words = text.split(' ').filter(w => w.trim());
            currentWordIndex = 0;

            if (words.length === 0) return;

            // Clear and setup track
            subtitleTrack.innerHTML = '';
            subtitlesEl.style.display = 'block';

            // Add all words to track
            words.forEach((word, i) => {
                const span = document.createElement('span');
                span.className = 'word';
                span.textContent = word;
                span.dataset.index = i;
                subtitleTrack.appendChild(span);
            });

            const wordElements = subtitleTrack.querySelectorAll('.word');

            // Handle single-word case - no interval needed
            if (words.length <= 1) {
                wordElements[0].classList.add('current');
                setTimeout(() => {
                    subtitlesEl.style.display = 'none';
                    subtitleTrack.style.transform = 'translateX(0)';
                }, duration + 1000);
                return;
            }

            const interval = duration / words.length;

            // Highlight first word
            wordElements[0].classList.add('current');

            // Calculate word width for smooth scrolling
            let cumulativeOffset = 0;

            karaokeInterval = setInterval(() => {
                if (currentWordIndex < words.length - 1) {
                    // Remove current highlight
                    wordElements[currentWordIndex].classList.remove('current');

                    // Calculate how much to scroll (word width + gap)
                    const currentWordEl = wordElements[currentWordIndex];
                    const wordWidth = currentWordEl.offsetWidth + 16; // 16px gap
                    cumulativeOffset += wordWidth;

                    currentWordIndex++;

                    // Highlight next word
                    wordElements[currentWordIndex].classList.add('current');

                    // Smooth scroll to keep current word centered
                    subtitleTrack.style.transform = `translateX(-${cumulativeOffset}px)`;
                } else {
                    clearInterval(karaokeInterval);
                    karaokeInterval = null;
                    setTimeout(() => {
                        subtitlesEl.style.display = 'none';
                        subtitleTrack.style.transform = 'translateX(0)';
                    }, 1000);
                }
            }, interval);
        }

        async function startListening() {
            console.log('[VoiceWindow] startListening() called, current state:', currentState);
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                audioContext = new AudioContext({ sampleRate: 48000 });
                const source = audioContext.createMediaStreamSource(mediaStream);

                try {
                    await audioContext.audioWorklet.addModule('workers/audio.processor.js');
                    workletNode = new AudioWorkletNode(audioContext, 'audio-capture-processor');

                    workletNode.port.onmessage = (event) => {
                        if (!isListening) return;
                        if (event.data.type === 'audio') {
                            const downsampled = downsample(event.data.buffer, audioContext.sampleRate, 16000);
                            const int16Data = float32ToInt16(downsampled);
                            window.voiceApi.send('audio-data', int16Data.buffer);
                        }
                    };

                    source.connect(workletNode);
                } catch (e) {
                    // Fallback to ScriptProcessor for older browsers
                    scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                    scriptProcessor.onaudioprocess = (e) => {
                        if (!isListening) return;
                        const inputData = e.inputBuffer.getChannelData(0);
                        const downsampled = downsample(inputData, audioContext.sampleRate, 16000);
                        const int16Data = float32ToInt16(downsampled);
                        window.voiceApi.send('audio-data', int16Data.buffer);
                    };
                    source.connect(scriptProcessor);
                    scriptProcessor.connect(audioContext.destination);
                }

                isListening = true;
                setState(currentVoiceResults.length > 0 ? VoiceState.AWAITING_SELECTION : VoiceState.LISTENING);

                // Always request fresh screen capture
                screenCaptured = false;
                window.voiceApi.send('capture-screen');
            } catch (err) {
                statusEl.textContent = 'Mic Error';
                // Notify main process about mic error
                try {
                    window.voiceApi.send('close-voice-window');
                } catch (ipcErr) { /* ignore */ }
            }
        }

        function stopListening() {
            isListening = false;

            if (workletNode) {
                try {
                    workletNode.disconnect();
                    workletNode = null;
                } catch (e) { }
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
                audioContext = null;
            }

            if (currentState === VoiceState.LISTENING || currentState === VoiceState.AWAITING_SELECTION) {
                setState(VoiceState.PROCESSING);
            }
        }

        let shouldListenAgain = false;

        window.voiceApi.receive('continue-listening', () => {
            // Only continue if within auto-listen limit
            if (canAutoListen()) {
                shouldListenAgain = true;
                consecutiveListenCount++;
                console.log(`[VoiceWindow] continue-listening received. shouldListenAgain set to true. Listen count: ${consecutiveListenCount}/${MAX_CONSECUTIVE_LISTENS}`);
            } else {
                console.log('Max consecutive listens reached. Waiting for explicit user trigger.');
                shouldListenAgain = false;
            }
        });

        function playAudioResponse(audioDataUrl, responseText) {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            if (karaokeInterval) {
                clearInterval(karaokeInterval);
            }

            currentAudio = new Audio(audioDataUrl);
            isSpeaking = true;
            setState(VoiceState.SPEAKING);

            currentAudio.onloadedmetadata = () => {
                const duration = currentAudio.duration * 1000;
                startKaraoke(responseText, duration);
            };

            currentAudio.onended = () => {
                isSpeaking = false;

                // Check if we need to continue for selection or follow-up
                if (currentVoiceResults.length > 0) {
                    // Results are showing, wait for selection - don't close
                    setState(VoiceState.SHOWING_RESULTS);
                    // Start listening for selection
                    setTimeout(() => startListening(), 300);
                } else if (shouldListenAgain) {
                    console.log('[VoiceWindow] Audio ended, shouldListenAgain is TRUE, calling startListening()');
                    shouldListenAgain = false;
                    // consecutiveListenCount is already incremented in continue-listening handler
                    setState(VoiceState.LISTENING);
                    setTimeout(() => startListening(), 200);
                } else {
                    setState(VoiceState.IDLE);
                    setTimeout(() => {
                        // Only auto-close if no results are showing
                        if (currentVoiceResults.length === 0) {
                            window.voiceApi.send('auto-close-voice');
                        }
                    }, 1500);
                }
            };

            currentAudio.onerror = () => {
                isSpeaking = false;
                setState(VoiceState.IDLE);
                statusEl.textContent = 'Audio Error';
            };

            currentAudio.play().catch(err => {
                statusEl.textContent = 'Playback Failed';
            });
        }

        // IPC Listeners
        window.voiceApi.receive('screen-captured', (imageData) => {
            screenCaptured = true;
            capturedImage = imageData;
        });

        window.voiceApi.receive('stt-partial-result', (text) => {
            if (text) {
                partialEl.textContent = text;
            }
        });

        window.voiceApi.receive('stt-result', (text) => {
            partialEl.textContent = '';

            // Check if we're awaiting a selection
            if (currentState === VoiceState.AWAITING_SELECTION && currentVoiceResults.length > 0) {
                stopListening();
                const selection = parseSelectionFromVoice(text);

                if (selection === 'cancel') {
                    hideVoiceResults();
                    window.voiceApi.send('auto-close-voice');
                    return;
                } else if (typeof selection === 'number') {
                    selectResult(selection);
                    return;
                }
                // If no valid selection, treat as new query
            }

            stopListening();
            setState(VoiceState.PROCESSING);

            window.voiceApi.send('voice-query', {
                query: text,
                image: capturedImage
            });
        });

        window.voiceApi.receive('voice-response', (data) => {
            if (data.text) {
                words = data.text.split(' ').filter(w => w.trim()); // Store for karaoke
                statusEl.textContent = 'Synthesizing';
                if (data.audio) {
                    playAudioResponse(data.audio, data.text);
                }
            }
        });

        window.voiceApi.receive('voice-audio-ready', (audioDataUrl) => {
            if (audioDataUrl && words.length > 0) {
                const responseText = words.join(' ');
                playAudioResponse(audioDataUrl, responseText);
            } else if (shouldListenAgain) {
                // Audio synthesis failed or no words, but we need to listen again
                console.log('[VoiceWindow] Audio failed, but shouldListenAgain is true - starting listening');
                shouldListenAgain = false;
                setState(VoiceState.LISTENING);
                setTimeout(() => startListening(), 200);
            }
        });

        // Handle search results display in voice mode
        window.voiceApi.receive('voice-search-results', (results) => {
            try {
                const data = typeof results === 'string' ? JSON.parse(results) : results;

                // New format with pre-formatted results array
                if (data.results && Array.isArray(data.results)) {
                    // Normalize items to expected shape { type, data }
                    currentVoiceResults = data.results.map(item => ({
                        type: item.type,
                        data: item.data !== undefined ? item.data : item
                    }));
                    voiceResultsListEl.innerHTML = '';

                    data.results.forEach((item, i) => {
                        let iconSvg, iconClass;
                        if (item.type === 'app') {
                            iconSvg = getAppIcon();
                            iconClass = 'app-icon';
                        } else if (item.type === 'folder') {
                            iconSvg = getFolderIcon();
                            iconClass = 'folder-icon';
                        } else {
                            iconSvg = getFileIcon();
                            iconClass = '';
                        }

                        const resultItem = createResultItem(i + 1, item.name, item.type, iconClass, iconSvg);
                        voiceResultsListEl.appendChild(resultItem);
                    });

                    if (currentVoiceResults.length > 0) {
                        voiceResultsEl.classList.add('visible');
                        setState(VoiceState.SHOWING_RESULTS);
                    }
                } else {
                    // Old format with apps/files/folders
                    displayVoiceResults(data);
                }

                // After showing results, start listening for selection
                if (data.waitingForSelection) {
                    setTimeout(() => {
                        startListening();
                    }, 500);
                }
            } catch (e) {
                console.error('[VoiceWindow] Failed to parse search results:', e);
            }
        });

        window.voiceApi.receive('start-listening', () => {
            // Explicit user trigger resets the consecutive listen counter
            resetListenCounter();
            startListening();
        });

        window.voiceApi.receive('stop-listening', () => {
            stopListening();
        });

        // Prevent accidental close when clicking on results
        document.getElementById('voice-results').addEventListener('click', (e) => {
            e.stopPropagation();
        });

        document.body.addEventListener('click', (e) => {
            // Don't close if clicking on results panel
            if (e.target.closest('#voice-results')) return;

            stopListening();
            hideVoiceResults();
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if (karaokeInterval) {
                clearInterval(karaokeInterval);
            }
            setState(VoiceState.IDLE);
            window.voiceApi.send('close-voice-window');
        });

        window.addEventListener('load', () => {
            window.voiceApi.send('voice-window-ready');
        });

        window.addEventListener('beforeunload', () => {
            stopListening();
            hideVoiceResults();
            window.voiceApi.send('voice-window-closed');
        });
    </script>
</body>

</html>